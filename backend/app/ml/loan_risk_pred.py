# -*- coding: utf-8 -*-
"""loan_risk_pred

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_9l6kRsI7JqlFSsU2x2D8KN1VU3v2VxY
"""

import pandas as pd
import numpy as np
df=pd.read_csv("/content/Loan.csv")

pd.set_option('display.max_columns', None) # Set the option using a string 'display.max_columns'
df.head()

df.info()

df1=df.drop(["ApplicationDate"],axis=1)

df1.describe()

categories = ['EmploymentStatus',	'EducationLevel','MaritalStatus','NumberOfDependents','HomeOwnershipStatus','LoanPurpose','LoanApproved']

import seaborn as sns
import matplotlib.pyplot as plt

for i in categories:

  fig, axes = plt.subplots(1, 2, figsize=(12, 6))  # Create a figure with 2 subplots

  # Box plot
  sns.boxplot(x=i, y='RiskScore', data=df, ax=axes[0])
  axes[0].set_title('Box Plot')

  # Violin plot
  sns.violinplot(x=i, y='RiskScore', data=df, ax=axes[1])
  axes[1].set_title('Violin Plot')

  plt.tight_layout()  # Adjust layout for better spacing
  plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

# Assuming 'df1' is your DataFrame and 'categories' is your list of columns to exclude
# ... (Your previous code to load and prepare data) ...

# Get a list of all columns in the DataFrame
all_columns = df1.columns.tolist()

# Remove columns in 'categories' from 'all_columns'
columns_to_correlate = [col for col in all_columns if col not in categories]

# Calculate the correlation matrix for the selected columns
correlation_matrix = df1[columns_to_correlate].corr()

# Create the heatmap
plt.figure(figsize=(12, 10))  # Adjust the figure size as needed
sns.heatmap(correlation_matrix, annot=False, cmap='coolwarm', fmt=".2f")
plt.title("Correlation Matrix Heatmap (Excluding Categories)")
plt.show()

df2=df1.drop(categories,axis=1)

df3=df2.drop(['LoanDuration','MonthlyDebtPayments','NumberOfOpenCreditLines','NumberOfCreditInquiries','PaymentHistory','SavingsAccountBalance','CheckingAccountBalance','TotalLiabilities','UtilityBillsPaymentHistory','JobTenure','MonthlyLoanPayment'],axis=1)

!pip install scikit-learn

import pandas as pd
from sklearn.model_selection import train_test_split

# Assuming 'df' is your DataFrame and 'TargetVariable' is your target column
X = df3.drop(['RiskScore'], axis=1)  # Features (all columns except the target)
y = df3['RiskScore']  # Target variable
#y = df['LoanApproved']  # Target variable

# Split the data into training and testing sets (e.g., 80% train, 20% test)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Print the shapes of the resulting sets
print("X_train shape:", X_train.shape)
print("X_test shape:", X_test.shape)
print("y_train shape:", y_train.shape)
print("y_test shape:", y_test.shape)

X_train.head()

from sklearn.ensemble import RandomForestRegressor  # For regression
from sklearn.ensemble import RandomForestClassifier # For Classification
from sklearn.metrics import mean_squared_error, r2_score, accuracy_score  # For regression evaluation
#OR
#from sklearn.metrics import accuracy_score, classification_report #For classification evaluation

# Create a RandomForestRegressor object
rf_model = RandomForestRegressor(random_state=42)  # You can adjust hyperparameters here

# Train the model using your training data
rf_model.fit(X_train, y_train)

# Make predictions on the test data
y_pred = rf_model.predict(X_test)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")